# Introduction to .NET

## Goals
- Understanding what a solution is and where it is located in a multi-project build.
- Understanding what a project is and where it is located in a multi-project build.
- Understanding the relationship between solutions and projects.
- Understanding (internal) dependencies between projects in a multi-project build.
- Understanding (external) dependencies of projects.
- Creating artifacts of each project.
- Packaging the entire application (each project/artifact of the application).

## Required tools
### Git
In this tutorial we will be using Git. To check and make sure you have a version of Git installed, please run the
following command. If the command returns an error, please install Git
```shell
git --version
```

### Dotnet
Please make sure you have installed a version of .NET. This tutorial assumes .NET 6+. You can check which version of .NET is installed by running 
```shell
dotnet --version
```

# 1. Create a git repository
- Create a project directory for this tutorial somewhere.
- In this directory, create a Git repository
    ```shell
    git init
    ```
- Create a file named '.gitignore' and ignore all directories which do not contain sources.
    ```shell
    touch .gitignore
    ```
- Add the following
    ```gitignore
    # User-specific files
    *.suo
    *.user
    
    # Build results
    [Bb]in/
    [Oo]bj/
    
    # MSTest test Results
    [Tt]est[Rr]esult*/
    [Bb]uild[Ll]og.*
    
    # Visual Studio 2015/2017 cache/options directory
    .vs/

    # VSCode
    .vscode/*
    !.vscode/settings.json
    !.vscode/tasks.json
    !.vscode/launch.json
    !.vscode/extensions.json
    !.vscode/*.code-snippets
    ```
- Commit the .gitignore

# 2. Create a solution file to contain all the projects
- Every project should be contained within its own directory. In the case of dotnet you'll use the `dotnet` CLI tool to create these projects and link them into the solution file (.sln).
- Solution files are not mandatory, but highly recommended. Solutions help group projects and define global configurations. IDEs such as VS Code, Visual Studio and Rider depend on them for showing your project/application as a whole.
- the `dotnet` CLI tool has a command named `new` to create instances of templates. Please create a new solution using `dotnet new` command with the name `MyApp`.
  <details>
    <summary>See solution</summary>

    ```shell
      dotnet new sln --name MyApp
    ```
  </details>

# 3. Creating the the projects
- .NET works a little different that the Java world some are already a bit familiar with. In Java the application sources and test sources live together in the same module under different directories (src/main/java and src/test/java). In .NET tests are in a separate project/assembly from the application code. The common pattern is to have a the application project and then another prefixed by `.Tests`. For example `MyApp.Domain` and `MyApp.Domain.Tests`.

- There is a good reasoning for this: .NET doesn't/didn't differentiate between what external dependencies are test-scoped and which ones are build/runtime scoped. Hence it required a seperate project for tests so you wouldn't pull test dependencies into your published production application.

- We will again use the `dotnet new` CLI command tool to create projects.


## 3.1 Domain sources
- Create the domain project first using `dotnet new`. Since this is purely domain logic create this as a class library type project with the name `MyApp.Domain`.
- By default the `dotnet` CLI tool does not add projects to the solution file. use `dotnet sln` to add the project we just created to the solution

  <details>
    <summary>See solution</summary>

    ```shell
    dotnet new classlib --name MyApp.Domain
    dotnet sln add MyApp.Domain
    ```
  </details>

- Populate the project directory of `MyApp.Domain`.
  Add a domain class 'Note.cs' to the project directory. You can remove the autogenerated `Class1.cs` file.
  <details>
    <summary>Please use this code</summary>
  
    ```c#
    namespace MyApp.Domain;

    public class Note
    {
        // A dummy domain class

        private string text = "Hello World";
        public string Text { get { return text; }  }
    }
    ```
    In directory
    ```
    .
    └── MyApp.Domain
        └── Note.cs
    ```
  </details>

- Build the whole solution and project using the `dotnet` task for building.
  <details>
    <summary>See solution</summary>

    ```shell
    dotnet build
    ```
  </details>

- Make sure the build succeeded by finding the assembly DLL named `MyApp.Domain.dll` in `MyApp.Domain/bin/debug/net7.0` (adjust for your version of .NET installed)


## 3.2 Domain tests
- Create the domain test project using `dotnet new`. For now creat it as a class library type project with the name `MyApp.Domain.Tests`. There are templates for multiple test frameworks, but we will do it by hand first and use the template in a later step. Again also add it to the solution file

  <details>
    <summary>See solution</summary>

    ```shell
    dotnet new classlib --name MyApp.Domain.Tests
    dotnet sln add MyApp.Domain.Tests
    ```
  </details>

- We are going to use xUnit as our testing framework. So we want to include it in our `MyApp.Domain.Tests` project. For exercise we'll use both the `dotnet` CLI and do it manually. 

- Open up your `MyApp.Domain.Tests/MyApp.Domain.Tests.csproj` file. We'll want to make some modifications to make this a real test project. First of we want to set `IsPackable` to `false` and `IsTestProject` to true. To do this find the `PropertyGroup` that contains the `TargetFramework` and add them there. Be sure to save the file. This will make this test projects not packagable as application or NuGet package and will mark it as a test project, helping with discovery by tools like IDEs.
  <details>
    <summary>See solution</summary>

    ```xml
    <Project Sdk="Microsoft.NET.Sdk">
      <PropertyGroup>
        <TargetFramework>net7.0</TargetFramework>
        ... more things here...

        <IsPackable>false</IsPackable>
        <IsTestProject>true</IsTestProject>
      </PropertyGroup>
    </Project>
    ```
  </details>

- Next we will add the `xunit.runner.visualstudio` dependency first. This dependency will add support for running xUnit tests in Visual Studio and under VSTest. We choose this one as it has a complexer configuration which is needed but at this time will not be explained. please use the `dotnet` CLI `add` command to add `xunit.runner.visualstudio` as a dependency in the `MyApp.Domain.Tests` project.

- Inspect the `MyApp.Domain.Tests/MyApp.Domain.Tests.csproj` after adding the dependency. The CLI should have added a `PackageReference` for you.

  <details>
    <summary>See solution</summary>

    ```shell
    dotnet add MyApp.Domain.Tests package xunit.runner.visualstudio
    ```

    This should yield a MyApp.Domain.Tests/MyApp.Domain.Tests.csproj similar to
    
    ```xml
    <Project Sdk="Microsoft.NET.Sdk">
      <PropertyGroup>
       ... snip ...
      </PropertyGroup>

      <ItemGroup>
        <PackageReference Include="xunit.runner.visualstudio" Version="2.4.5">
          <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
          <PrivateAssets>all</PrivateAssets>
        </PackageReference>
      </ItemGroup>

    </Project>
    ```
  </details>

- Create two more `PackageReference`s by hand. Create one for `xunit` version "2.4.2" and one for `Microsoft.NET.Test.Sdk` version "17.6.2". They do not need the IncludeAssets and PrivateAssets part.
  <details>
    <summary>See solution</summary>

    ```xml
    <Project Sdk="Microsoft.NET.Sdk">
      <PropertyGroup>
       ... snip ...
      </PropertyGroup>

      <ItemGroup>
        <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.6.2" />
        <PackageReference Include="xunit" Version="2.4.2" />
        <PackageReference Include="xunit.runner.visualstudio" Version="2.4.5">
          <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
          <PrivateAssets>all</PrivateAssets>
        </PackageReference>
      </ItemGroup>
    </Project>
    ```
  </details>

- Populate the project directory of `MyApp.Domain.Tests`.
  with a test. You can remove the autogenerated `Class1.cs` file.
  <details>
    <summary>Please use this code</summary>

    ```c#
    namespace MyApp.Domain.Tests;
    using Xunit;
    using MyApp.Domain;

    public class NoteTest
    {
        [Fact]
        public void Test()
        {
            var note = new Note();
            Assert.Equal("Hello Word", note.Text);
        }
    }
    ```
    In
    ```
    .
    └── MyApp.Domain.Tests
        └── NoteTest.cs
    ```
  </details>
  
- Downloading dependencies happens using NuGet. This is usually an implicit step done in all the other commands you can run in the `dotnet` CLI. For now we will run it manually once so we can see what it does. please run `dotnet restore`

- Firstly it will walk the solution/projects search for all package references. It will then try to find and download these packages from the public NuGet repository. These downloaded files will get stored somewhere in your user profile (`~/.nuget` on Linux, `%USERDIR%/.nuget` on windows). It will then populate the `obj/` folder of each project with files describing to .NET tooling where to find the dependencies. You should see something similar in terms of files like this:

    ```shell
    .
    ├── MyApp.Domain.Tests
    │   ├── MyApp.Domain.Tests.csproj
    │   ├── obj
    │   │   ├── MyApp.Domain.Tests.csproj.nuget.dgspec.json
    │   │   ├── MyApp.Domain.Tests.csproj.nuget.g.props
    │   │   ├── MyApp.Domain.Tests.csproj.nuget.g.targets
    │   │   ├── project.assets.json
    │   │   └── project.nuget.cache

    ```

- Run the tests with `dotnet test`. this should do three things. 1) Restore using NuGet to download the dependencies. 2) Build all the projects. 3) run all the test projects. You should see it fail, as the test project cannot be built as it cannot find the `Note`.

- Use the `dotnet add` command in reference mode to add a reference from `MyApp.Domain.Tests` to `MyApp.Domain`
  <details>
    <summary>See solution</summary>
    
    ```shell
    dotnet add MyApp.Domain.Tests reference MyApp.Domain
    ```

    if you observe MyApp.Domain.Tests/MyApp.Domain.Tests.csproj you'll see that it added a ProjectReference.
  </details>

- Modify the tests to run successfully and rerun the build. 

# 4. Add another project
Using all our gathered knowledge from the previous chapters, we can add a new shiny service project.
- Create a new class library project for `MyApp.Service`
- Create a new test project for that Service library. Instead of doing it manually you may also run `dotnet new xunit --name MyApp.Service.Tests` and let dotnet create a premade template for you.
- Make sure to add both to the solution file
- Make sure the service test project also correctly runs its unit tests.

# 5. Dependencies between projects
- Add a dependency to the service project either via `dotnet` CLI or manually, so we can use classes from our domain. Apply what you already learned linking the test project and the class library of the Domain project.
  ```mermaid
  graph TD
    project-service[Service] --> project-domain[Domain] 
  ```
  <details>
    <summary>See solution</summary>

    ```shell
    dotnet add MyApp.Service reference MyApp.Domain
    ```

    or manually in `MyApp.Service/MyApp.Service.csproj`

    ```xml
    <Project Sdk="Microsoft.NET.Sdk">
      <PropertyGroup>
      ... snip ..
      </PropertyGroup>

      <ItemGroup>
        <ProjectReference Include="..\MyApp.Domain\MyApp.Domain.csproj" />
      </ItemGroup>
    </Project>

    ```
  </details>

- Add a service class in the service class library project.

  <details>
    <summary>Please use this code</summary>

    in MyApp.Service/Service.cs

    ```c#
    namespace MyApp.Service;
    using MyApp.Domain;

    public class Service
    {
        private Note ourSingletonNote = new Note();

        public Note getOurOnlyNote() {
            return ourSingletonNote;
        }
    }
    ```
  </details>

- Write a test in the service test project which uses this service class,which indirectly uses the domain class.
  <details>
    <summary>Please use this code</summary>

    in MyApp.Service.Tests/ServiceTest.cs

    ```c#
    namespace MyApp.Service.Tests;
    using MyApp.Service;

    public class ServiceTest
    {
        [Fact]
        public void Test()
        {
            var service = new Service();
            Assert.NotNull(service.getOurOnlyNote());
        }
    }
    ```
  </details>


# 6. Create a build of the entire application
- Create a new project called `MyApp.App`. Use the `dotnet` CLI tool to create it based of the `console` template. This will ensure you will get an executable. By convention dotnet will run the `Program.cs` file as entrypoint for console applications
- Ensure you added it to the solution file.
- Add dependencies to both the `Domain` and `Service` projects.
  <details>
    <summary>See solution</summary>

    ```shell
    dotnet new console --name MyApp.App
    dotnet sln add MyApp.App
    dotnet add MyApp.App reference MyApp.Domain
    dotnet add MyApp.App reference MyApp.Service
    ```

    this should result in a MyApp.App/MyApp.App.csproj looking somewhat like this

    ```xml
    <Project Sdk="Microsoft.NET.Sdk">

      <PropertyGroup>
        <OutputType>Exe</OutputType>
        ... snip ...
      </PropertyGroup>

      <ItemGroup>
        <ProjectReference Include="..\MyApp.Domain\MyApp.Domain.csproj" />
        <ProjectReference Include="..\MyApp.Service\MyApp.Service.csproj" />
      </ItemGroup>

    </Project>
    ```
  </details>
- Run the build and see if everything works. There should be a file called `MyApp.App/bin/Debug/net7.0/MyApp.App.exe`(Windows) or `MyApp.App/bin/Debug/net7.0/MyApp.App`(Linux)
  ```shell
  dotnet build
  ```
- If you inspect the `MyApp.App/bin/Debug/net7.0/` directory you will see it pulled all the compiled assemblies/DLLs from the referenced projects.

- To finish everything off we'll make use of the `Service` from the console application and print out the text from the `Note`.
  <details>
    <summary>See solution</summary>

    in MyApp.App/Program.cs

    ```c#
    using MyApp.Service;

    var service = new Service();
    var note = service.getOurOnlyNote();
    Console.WriteLine(note.Text);
    ```
  </details>

- Now run the application using `dotnet run --project MyApp.App` or by building and manually running the `MyApp.App/bin/Debug/net7.0/MyApp.App.exe`(Windows) or `MyApp.App/bin/Debug/net7.0/MyApp.App`(Linux) file. 
